<!doctype html>
<html lang="en">
<head>
    <title>Leo Qi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="ECE 203 course notes" />
    <link rel="stylesheet" href="https://latex.vercel.app/style.min.css" />
    <link rel="icon" href="favicon.ico" />
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://latex.vercel.app/prism/prism.css">
    <script src="https://cdn.jsdelivr.net/npm/prismjs/prism.min.js"></script>
</head>
<body class="libertinus">
  <header>
    <h1>Logic 2</h1>
    <p class="author">Leo Qi <br> December 4th, 2024</p>
  </header>
  <div class="abstract">
    <h2>Abstract</h2>
    <p>Let's document our discovery of formal logic.</p>
  </div>
  <nav role="navigation" class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#propositional-logic">Propositional logic</a></li>
      <li><a href="#predicate-logic">Predicate logic</a></li>
      <li><a href="#case-splitting">Case splitting</a></li>
      <li><a href="#induction">Natural number induction</a></li>
      <li><a href="#induction-list">List induction</a></li>
    </ol>
  </nav>
  <main>
  <article class="indent-pars">
    <h2 id="propositional-logic">Propositional logic</h2>

    <h2 id="case-splitting">Case splitting</h2>
    <div class="definition">
      Case splitting is when we decompose a proof into multiple independent
      cases. In the syntax of the course, we use the <code>Cases</code> rule
      to do so.<sup><a href="#fn1" id="ref1">1</a></sup>
    </div>

    <pre>
      <code class="language-lean">
        Var (x : Nat)
        |- P
        By Cases x < 10, x >= 10 /\ even x, x >= 10 /\ odd x;
        {
          Subproof 1: "completeness"
            QED Arith
          Subproof 2: "case 1"
            Asm 2/1: x < 10
            -- Continue subproof
          Subproof 3: "case 2"
            Asm 3/1: x >= 10 /\ even x
            -- Continue subproof
          Subproof 4: "case 3"
            Asm 4/1: x >= 10 /\ odd x
            -- Continue subproof
        }
      </code>
    </pre>

    <p>
      The goal is to first prove that the list of cases itself is complete and
      covers all possibilities; then, that for each of the subcases, prove our
      original goal. Cases may overlap. To justify that a trivial set of cases is
      complete, we may use the <code>Arith</code> or <code>Logic</code> tactics.
    </p>

    <h2 id="induction">Natural number induction</h2>
    <p>
      Induction is a proof technique that is used to prove a property for all
      natural numbers. The idea is to prove the property for the base case, and
      then prove that if the property holds for \(n\), it also holds for \(n+1\).
      Our goal is therefore \(\forall(n : \mathbb{N}),\ p(n)\) for some predicate
      \(p\).
    </p>
    <p>
      Natural number induction may only be applied to goals where the
      <em>outermost operator is a universal quantifier</em> over a variable
      of type \(\mathbb{N}\).
    </p>
    <div class="definition">
      Natural induction is a proof technique that is used to prove a predicate
      holds for all natural numbers. It has
      <ul>
        <li>A goal, \(\forall(n : \mathbb{N}),\ p(n)\)</li>
        <li>A proof rule, <code>InductNat</code></li>
        <li>A base case has no new assumptions and the goal \(p(0)\)</li>
        <li>An inductive case with assumption that for an arbitrary \(n\),
          \(p(n)\) holds, and the goal is \(p(n+1)\)</li>
      <ul>
    </div>
    <p>
      We can also distinguish between induction, <em>strong induction</em>,
      and <em>positive number induction</em>.
    </p>
    <div class="definition">
      Strong induction is induction where the inductive case not only assumes
      that the property holds for \(n\), but also for all \(m \leq n\).

      <ul>
        <li>Goal is \(\forall(n : \mathbb{N}),\ p(n)\)</li>
        <li>Proof rule is <code>InductStrongNat</code></li>
        <li>Base case has goal \(p(0)\)</li>
        <li>Inductive case assumes that given arbitrary \(n\),
          \(\forall(m\le n), p(m)\), and the goal is \(p(n+1)\)</li>
    </div>
    <p>
      In general, inductive proofs are used to prove things about objects that
      have recursive definitions.
    </p>

    <h2 id="induction-list">List induction</h2>
    <p>
      List induction can be used to prove some property for all lists. The idea
      is to prove the property for an empty list, and then prove that if the
      property holds for an arbitrary list, it also holds for the list with an
      additional element. Our goal is therefore
      \(\forall(xs : \text{List } Ty),\ P(xs)\).
    </p>
    <pre>
      <code class="language-lean">
        |- \forall(xs : List Ty), P(xs)
        By InductList
        {
          Subproof 1: "base case"
            |- P[]
            QED -- show that this satisfies goal
          Subproof 2: "inductive case"
            Asm 2/1: Var (xs: List Ty)
            Asm 2/2: P xs
            Asm 2/3: Var (x: Ty)
              |- P(x :: xs)
              -- Continue subproof
        }
      </code>
    </pre>
    <p>
      In the above, the notation <code>P(x :: xs)</code> refers to the predicate
      applied to the list with new element <code>x</code> "pushed" onto it.
      The push operation appends a new element to the front of the list.
      For example:
    </p>
    <pre>
      <code class="language-lean">
        size [13,12,11]
        = 1 + size[12,11]
        = 1 + 1 + size[11]
        = 1 + 1 + 1 + size[]
        = 1 + 1 + 1 + 0
        = 1 + 1 + 1
        = 1 + 2
        = 3
      </code>
    </pre>
    <p>
      Likewise, here is how we "splice" two lists together in a formal way.
    </p>
    <pre>
      <code class="language-lean">
        abbrev splice : (xs ys: List Ty) -> List Ty :=
          | [], ys => ys
          | x :: xs, ys => x :: (splice x ys)

        -- In operation
        xs1 = [0,1,2]
        xs2 = [10,11,12,13]

        splice(xs1, xs2)
          = splice([0,1,2], [10,11,12,13])
          = 0 :: splice([1,2], [10,11,12,13])
          = 0 :: 1 :: splice([2], [10,11,12,13])
          = 0 :: 1 :: 2 :: splice([], [10,11,12,13])
          = 0 :: 1 :: 2 :: [10,11,12,13]
          = 0 :: 1 :: [2,10,11,12,13]
          = 0 :: [1,2,10,11,12,13]
          = [0,1,2,10,11,12,13]
      </code>
    </pre>

    <div class="footnotes">
      <p class="no-indent">Last updated: 2024-12-03 14:03 EST</p>
      <p class="no-indent" id="fn1">
        [1] M. Aagaard, &#8220;Lecture notes for ECE 208.&#8221;
        Dec. 2024. <a href="#ref1">&#x21A9;</a>
      </p>
    </div>
  </article>
</main>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
  <title>Logic 2 - Leo Qi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="ECE 203 course notes" />
    <link rel="stylesheet" href="/assets/latex.vercel.app.style.min.css" />
    <link id="MathJax-script" async defer src="/assets/npm.mathjax3.es5.tex-mml-chtml.js" />
    <link rel="stylesheet" href="/assets/latex.vercel.app.prism.css" />
    <script async defer src="/assets/npm.prism.min.js"></script>
    <link rel="icon" href="/favicon.ico" />
  <style>
  /* width */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }

  /* Track */
  ::-webkit-scrollbar-track {
    background: #f1f1f1;
  }

  /* Handle */
  ::-webkit-scrollbar-thumb {
    background: #888;
  }

  /* Handle on hover */
  ::-webkit-scrollbar-thumb:hover {
    background: #555;
  }
  </style>
</head>
<body class="libertinus">
  <header>
    <h1>Logic 2</h1>
    <p class="author">Leo Qi <br> December 4th, 2024</p>
  </header>
  <div class="abstract">
    <h2>Abstract</h2>
    <p>Let's document our discovery of formal logic.</p>
  </div>
  <nav role="navigation" class="toc">
    <h2>Contents</h2>
    <ol>
      <li><a href="#propositional-logic">Propositional logic</a></li>
      <li><a href="#predicate-logic">Predicate logic</a></li>
      <li><a href="#case-splitting">Case splitting</a></li>
      <li><a href="#induction">Natural number induction</a></li>
      <li><a href="#induction-list">List induction</a></li>
    </ol>
  </nav>
  <main>
  <article class="indent-pars">
    <h2 id="propositional-logic">Propositional logic</h2>

    <h2 id="case-splitting">Case splitting</h2>
    <div class="definition">
      Case splitting is when we decompose a proof into multiple independent
      cases. In the syntax of the course, we use the <code>Cases</code> rule
      to do so.<sup><a href="#fn1" id="ref1">1</a></sup>
    </div>

    <pre>
      <code class="language-lean">
Var (x : Nat)
|- P
By Cases x < 10, x >= 10 /\ even x, x >= 10 /\ odd x;
{
  Subproof 1: "completeness"
    QED Arith
  Subproof 2: "case 1"
    Asm 2/1: x < 10
    -- Continue subproof
  Subproof 3: "case 2"
    Asm 3/1: x >= 10 /\ even x
    -- Continue subproof
  Subproof 4: "case 3"
    Asm 4/1: x >= 10 /\ odd x
    -- Continue subproof
}
      </code>
    </pre>

    <p>
      The goal is to first prove that the list of cases itself is complete and
      covers all possibilities; then, that for each of the subcases, prove our
      original goal. Cases may overlap. To justify that a trivial set of cases is
      complete, we may use the <code>Arith</code> or <code>Logic</code> tactics.
    </p>

    <h2 id="induction">Natural number induction</h2>
    <p>
      Induction is a proof technique that is used to prove a property for all
      natural numbers. The idea is to prove the property for the base case, and
      then prove that if the property holds for \(n\), it also holds for \(n+1\).
      Our goal is therefore \(\forall(n : \mathbb{N}),\ p(n)\) for some predicate
      \(p\).
    </p>
    <p>
      Natural number induction may only be applied to goals where the
      <em>outermost operator is a universal quantifier</em> over a variable
      of type \(\mathbb{N}\).
    </p>
    <div class="definition">
      Natural induction is a proof technique that is used to prove a predicate
      holds for all natural numbers. It has
      <ul>
        <li>A goal, \(\forall(n : \mathbb{N}),\ p(n)\)</li>
        <li>A proof rule, <code>InductNat</code></li>
        <li>A base case has no new assumptions and the goal \(p(0)\)</li>
        <li>An inductive case with assumption that for an arbitrary \(n\),
          \(p(n)\) holds, and the goal is \(p(n+1)\)</li>
      <ul>
    </div>
    <p>
      We can also distinguish between induction, <em>strong induction</em>,
      and <em>positive number induction</em>.
    </p>
    <div class="definition">
      Strong induction is induction where the inductive case not only assumes
      that the property holds for \(n\), but also for all \(m \leq n\).

      <ul>
        <li>Goal is \(\forall(n : \mathbb{N}),\ p(n)\)</li>
        <li>Proof rule is <code>InductStrongNat</code></li>
        <li>Base case has goal \(p(0)\)</li>
        <li>Inductive case assumes that given arbitrary \(n\),
          \(\forall(m\le n), p(m)\), and the goal is \(p(n+1)\)</li>
    </div>
    <p>
      In general, inductive proofs are used to prove things about objects that
      have recursive definitions.
    </p>

    <h2 id="induction-list">List induction</h2>
    <p>
      List induction can be used to prove some property for all lists. The idea
      is to prove the property for an empty list, and then prove that if the
      property holds for an arbitrary list, it also holds for the list with an
      additional element. Our goal is therefore
      \(\forall(xs : \text{List } Ty),\ P(xs)\).
    </p>
    <pre>
      <code class="language-lean">
|- \forall(xs : List Ty), P(xs)
By InductList
{
  Subproof 1: "base case"
    |- P[]
    QED -- show that this satisfies goal
  Subproof 2: "inductive case"
    Asm 2/1: Var (xs: List Ty)
    Asm 2/2: P xs
    Asm 2/3: Var (x: Ty)
    |- P(x :: xs)
    -- Continue subproof
}
      </code>
    </pre>
    <p>
      In the above, the notation <code>P(x :: xs)</code> refers to the predicate
      applied to the list with new element <code>x</code> "pushed" onto it.
      The push operation appends a new element to the front of the list.
      Here is how we "splice" two lists together in a formal way.
    </p>
    <pre>
      <code class="language-lean">
abbrev splice : (xs ys: List Ty) -> List Ty :=
  | [], ys => ys
  | x :: xs, ys => x :: (splice x ys)

-- In operation
xs1 = [0,1,2]
xs2 = [10,11,12,13]

splice(xs1, xs2)
  = splice([0,1,2], [10,11,12,13])
  = 0 :: splice([1,2], [10,11,12,13])
  = 0 :: 1 :: splice([2], [10,11,12,13])
  = 0 :: 1 :: 2 :: splice([], [10,11,12,13])
  = 0 :: 1 :: 2 :: [10,11,12,13]
  = 0 :: 1 :: [2,10,11,12,13]
  = 0 :: [1,2,10,11,12,13]
  = [0,1,2,10,11,12,13]
      </code>
    </pre>
   
    <h3>Size of a spliced list</h3>
    <p>
      Let's prove that if \(xs\) and \(ys\) are lists, then 
      <code>size (splice xs ys) = size xs + size ys</code> using list induction.
      The entirety of the proof is copied from Prof. Aagaard's lecture notes. <a href="#fn1" id="ref1">[1]</a>
      We'll use the definitions that
    <p>
    <pre>
      <code class="language-lean">
abbrev size : (List Ty) -> Nat
  | []        => 0
  | (x :: xs) => 1 + size xs

abbrev splice : (xs ys : List Ty) -> List Ty :=
  | []   , ys => ys
  | x::xs, ys => x :: (splice x ys)
      </code>
    </pre>
    <div class="proof">
      Proof via list induction.

      <pre>
        <code class="language-lean">
|- \forall (xs ys : List Ty), size splice xs ys = size xs + size ys
-- Induct on xs, because splice recurses on it. The second list
-- is held in place and pushed.
-- P(xs) = size splice xs ys = size xs + size ys, with fixed ys

By InductList
-- 1: induction is always done on the outermost operator in the goal, which
--    must be a universally quantified variable.
-- 2: induction is done on exactly one variable.
{
  Subproof 1: "base case"
    -- Base case: replace each occurence of xs with [] in the goal
    -- size [Ty] is taking the size of an empty list of type Ty.
    |- \forall (ys : List Ty), size splice [] ys = size [Ty] + size ys
    By ForallElim Goal
    Asm 1/1: Var (ys: List Ty)
    |- size splice [] ys = size [Ty] + size ys
    By Subst splice Into Goal
    |- size ys = size [Ty] + size ys
    By Subst size Into Goal
    |- size ys = 0 + size ys
    QED Arith
  Subproof 2: "inductive case"
    -- declare the list we induct on
    Asm 2/1: Var (xs: List Ty)
    -- inductive assumption: original goal with forall removed
    Asm 2/2: \forall(ys: List Ty), size splice xs ys = size xs + size ys
    -- declare the element we push onto the list
    Asm 2/3: Var (x: Ty)
    -- goal is original goal with xs replaced by x :: xs
    |- \forall(ys : List Ty), size splice (x :: xs) ys = size (x :: xs) + size ys
    ByForallElim Goal
    Asm 2/4: Var (ys: List Ty)
    |- size splice (x :: xs) ys = size (x :: xs) + size ys
    By Subst splice Into Goal
    |- size (x :: (splice xs ys)) = size (x :: xs) + size ys
    By Subst size Into Goal
    |- 1 + size (splice xs ys) = 1 + size xs + size ys
    By Subst Asm 2/2 Into Goal
    |- 1 + size xs + size ys = 1 + size xs + size ys
    QED Logic
}

-- Alternate proof strategy
abbrev alternate := Proof
  Asm 2/1: Var (xs: List Ty)
  Asm 2/2: \forall(ys: List Ty), size splice xs ys = size xs + size ys
  |- \forall(ys : List Ty), 1 + size splice xs ys = 1 + size xs + size ys
  By Assert Goal By Arith
  |- \forall(ys : List Ty), size splice xs ys = size xs + size ys
  QED Asm 2/2
        </code>
      </pre>
      <br />
    </div>

    <h2 id="induction-set">Set induction</h2>
    <p>

    </p>

    <div class="footnotes">
      <p class="no-indent">Last updated: 2024-12-03 14:03 EST</p>
      <p class="no-indent" id="fn1">
        [1] M. Aagaard, &#8220;Lecture notes for ECE 208.&#8221;
        Dec. 2024. <a href="#ref1">&#x21A9;</a>
      </p>
    </div>
  </article>
</main>
</body>
</html>
